<script>

    class CompressionManager {
        constructor(dataset, feature, title = null) {
            console.log("CompressionManager", dataset, feature)
            this.title = title;
            this.extremes = null;
            if (this.title == null) {
                this.title = feature;
            }

            this.feature = feature; // scarsity or outliers
            this.dataset = dataset;

            getCompressionData(dataset, feature).done(response => {
                console.log("data")

                this.data = response.data
                this.levels = Object.keys(this.data);

                this.levels = this.levels.sort((a, b) => {
                    let numA = parseFloat(a.replace(/[^0-9.]/g, ''));
                    let numB = parseFloat(b.replace(/[^0-9.]/g, ''));
                    return numA - numB;
                });

                console.log("levels", this.levels)
                this.currentLevel = this.levels[0];

                console.log(this.data)
                console.log(this.levels)
                console.log("curr", this.currentLevel)
                this.initialDataSet = this.data[this.currentLevel]["data"];

                this.columns = Object.keys(this.initialDataSet).filter((key) => {
                    return key !== 'time';
                });

                this.initialCompression = this.data[this.levels[0]]["compression"]

                this.chartTime = this.initialDataSet["time"].map((time) => {
                    return Date.parse(time);
                });
                this.createDropdown();
                this.initializeCharts();
            })
        }

        setChartExtremes() {
        }

        initializeCharts() {
            if (this.extremes != null) {
                this.extremes = this.dataChart.xAxis[0].getExtremes()
            }
            let chart_time = this.chartTime
            this.dataChart = Highcharts.chart(`data-container`, {
                    chart: {
                        type: 'line',
                        zoomType: 'x',
                        events: {
                            load() {
                                console.log("load")
                                const chart = this,
                                    startDate = Date.UTC(2021, 2, 26),
                                    endDate = Date.UTC(2021, 8, 26);
                                chart.xAxis[0].setExtremes(chart_time[chart_time.length - 500], chart_time[chart_time.length], true, false)
                            }
                        }
                    },

                    title: {
                        text: ""//this.title
                    },
                    xAxis: {
                        type: 'datetime',
                        ordinal: false,
                    },
                    yAxis: {
                        title: {
                            text: 'Value'
                        }
                    },
                    legend: {
                        enabled: true,
                        verticalAlign: 'top',
                    },
                    series: this.columns.map((column, index) => {
                        return {
                            name: column,
                            id: column,
                            visible: index === 0,
                            data: this.chartTime.map((time, index) => {
                                return [time, this.initialDataSet[column][index]]
                            })
                        }
                    }),
                    navigator: {
                        adaptToUpdatedData: false,
                        enabled: true, // Set to true to enable the navigator
                    },
                    credits: {
                        enabled: false,
                    },
                    rangeSelector: {
                        selected: 2,
                        enabled: true,
                        buttons: [{
                            type: 'millisecond',
                            count: 10000 * 6,
                            text: '1m'
                        }, {
                            type: 'millisecond',
                            count: 10000 * 6 * 10,
                            text: '10m'
                        }, {
                            type: 'millisecond',
                            count: 10000 * 6 * 60,
                            text: '1h'
                        }],
                    },

                },
            );
            this.setChartExtremes()
            const compressionManager = this;

            this.compressionChart = Highcharts.chart(`compression-container`, {
                chart: {
                    type: 'column',
                },
                plotOptions: {
                    series: {
                        cursor: 'pointer',
                        point: {
                            events: {
                                click: function () {
                                    compressionManager.setLevel(this.category)
                                }
                            }
                        }
                    }
                },
                title: {
                    text: ''
                },
                yAxis: {
                    title: {
                        text: 'Storage Size in KB'
                    }
                },
                xAxis: {
                    categories: ["","clickhouse", "druid", "influx", "timescaledb"],
                    labels: {
                        allowOverlap: true,
                        padding: 0,
                        enabled: false
                    },
                },

                series: Object.keys(this.initialCompression).map(system => {
                    return {
                        name: system,
                        color: {
                            "clickhouse": "#20B2AA",
                            "druid": "#FFA500",
                            "influx": "#FFB6C1",
                            "timescaledb": "#696969"
                        }[system],
                        data: [this.initialCompression[system]]
                    }
                })
            });
        }

        createDropdown() {
            const dropdown = document.createElement('select');
            dropdown.id = `inside-dropdown`;
            dropdown.className = 'form-control';
            dropdown.addEventListener('change', (event) => {
                this.setLevel(event.target.value)
                document.getElementById("showCompression").style.display = "none";
            });


            for (const level of this.levels) {
                const levelOption = document.createElement('option');
                levelOption.value = level;
                levelOption.text = level.split("_").length > 1 ? level.split("_")[1] : level;
                dropdown.add(levelOption);
            }
            const levelDropdown = document.getElementById('level-dropdown');
            levelDropdown.innerHTML = '';

            levelDropdown.appendChild(dropdown);

        }

        setLevel(level) {
            this.currentLevel = level;
        }

        displayCompression() {
            var level = this.currentLevel
            this.compressionChart.series.forEach((series) => {
                series.setData([this.data[level]["compression"][series.name]]);
            });
        }

        displayChart() {
            var level = this.currentLevel
            while (this.dataChart.series.length > this.columns.length) {
                this.dataChart.series[this.columns.length].remove(false);
             }

            // Update the charts based on the current level
            const newData = this.data[level]["data"];
            let counter = 0


            if (this.feature === "scarsity") {
                var used_colors = []
                this.dataChart.series.forEach(
                    //update series opacity and line style
                    (series) => {
                        series.update({
                            opacity: 0.5,
                            dashStyle: 'dot',
                        }, true);
                        used_colors.push(series.color)
                    }
                )
                for (const sensor of Object.keys(newData)) {
                    if (sensor === 'time') continue;
                    try {
                        const newChartData = newData[sensor].map((value, index) => [this.chartTime[index], value]);
                        {#this.dataChart.get(sensor).setData(newChartData);#}
                        //  delete series with index larger than 3

                        this.dataChart.addSeries({
                            name: sensor + "_" + level,
                            id: sensor + level,
                            data: newChartData,
                            linkedTo: sensor,
                            visible: counter === 0,
                            showInLegend: false,
                            color: used_colors[counter]
                        });
                    } catch (e) {
                        console.log(sensor);
                        console.log(e);
                    }
                    counter = counter + 1 // 3 sensors
                }

            } else if (this.feature === "outliers") {
                for (const sensor of Object.keys(newData)) {
                    if (sensor === 'time') continue;
                    try {
                        const newChartData = newData[sensor].map((value, index) => [this.chartTime[index], value]);

                        this.dataChart.addSeries({
                            name: sensor + "_" + level,
                            id: sensor + level,
                            data: newChartData,
                            linkedTo: sensor,
                            zIndex: -1,
                            color: 'rgba(255, 0, 0, 1)',
                            visible: counter === 0,
                            showInLegend: false,
                        });
                    } catch (e) {
                        console.log(sensor);
                        console.log(e);
                    }
                    counter = counter + 1 // 3 sensors
                }

            } else {
                var used_colors = []
                this.dataChart.series.forEach(
                    //update series opacity and line style
                    (series) => {
                        series.update({
                            opacity: 0.5,
                            dashStyle: 'dot',
                        }, true);
                        used_colors.push(series.color)
                    }
                )
                for (const sensor of Object.keys(newData)) {
                    if (sensor === 'time') continue;
                    try {
                        const newChartData = newData[sensor].map((value, index) => [this.chartTime[index], value]);
                        {#this.dataChart.get(sensor).setData(newChartData);#}
                        //  delete series with index larger than 3

                        this.dataChart.addSeries({
                            name: sensor + "_" + level,
                            id: sensor + level,
                            data: newChartData,
                            linkedTo: sensor,
                            visible: counter === 0,
                            showInLegend: false,
                            color: used_colors[counter]
                        });
                    } catch (e) {
                        console.log(sensor);
                        console.log(e);
                    }
                    counter = counter + 1 // 3 sensors
                }

            }
        }
    }

</script>