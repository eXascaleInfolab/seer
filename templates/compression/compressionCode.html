<script>

    class CompressionManager {
        constructor(dataType, title = null) {
            console.log("CompressionManager", dataType)
            this.title = title;
            this.extremes = null;
            if (this.title == null) {
                this.title = dataType;
            }

            this.dataType = dataType;
            getCompressionData(dataType).done(response => {
                console.log("data")

                this.data = response.data
                this.levels = Object.keys(this.data);
                this.currentLevel = this.levels[0];

                console.log(this.data)
                console.log(this.levels)
                console.log("curr", this.currentLevel)
                this.initialDataSet = this.data[this.currentLevel]["data"];

                this.initialCompression = this.data[this.levels[0]]["compression"]

                this.chartTime = this.initialDataSet["time"].map((time) => {
                    return Date.parse(time);
                });

                this.initializeCharts();
                this.createDropdown();
            })
        }

        setChartExtremes() {
            if (this.extremes == null) {
                let current_extremes = this.dataChart.xAxis[0].getExtremes()
                let dataMax = current_extremes.max
                console.log("setting extremes", dataMax)
                this.dataChart.xAxis[0].setExtremes(dataMax - (1000 * 60 * 10), dataMax, true, false)
            }
            else {
               let current_extremes = this.extremes
                let dataMax = current_extremes.max
                let dataMin = current_extremes.min
                console.log("setting extremes", dataMax)
                this.dataChart.xAxis[0].setExtremes(dataMin, dataMax, true, false)
            }
            this.extremes = this.dataChart.xAxis[0].getExtremes()
        }

        initializeCharts() {
            if(this.extremes != null){
                this.extremes = this.dataChart.xAxis[0].getExtremes()
            }
            this.dataChart = Highcharts.chart(`data-container`, {
                    chart: {
                        type: 'line',
                        zoomType: 'x'
                    },
                    title: {
                        text: ""//this.title
                    },
                    xAxis: {
                        type: 'datetime',
                        ordinal: false,
                    },
                    yAxis: {
                        title: {
                            text: 'Value'
                        }
                    },
                    legend: {
                        enabled: true,
                        verticalAlign: 'top',
                    },
                    series: [{ // [ time.1 ,  scarsity_data['s0'][1] ..... ]
                        name: 's0',
                        id: 's0',
                        data: this.chartTime.map((time, index) => {
                            return [time, this.initialDataSet['s0'][index]]
                        })
                    },
                        {
                            name: 's1',
                            id: 's1',
                            visible: false,
                            data: this.chartTime.map((time, index) => {
                                return [time, this.initialDataSet['s1'][index]]
                            })
                        },
                        {
                            name: 's2',
                            id: 's2',
                            visible: false,
                            data: this.chartTime.map((time, index) => {
                                return [time, this.initialDataSet['s2'][index]]
                            })
                        }],
                    navigator: {
                        adaptToUpdatedData: false,
                        enabled: true, // Set to true to enable the navigator
                    },
                    credits: {
                        enabled: false,
                    },
                    rangeSelector: {
                        selected: 2,
                        enabled: true,
                        buttons: [{
                            type: 'millisecond',
                            count: 10000 * 6,
                            text: '1m'
                        }, {
                            type: 'millisecond',
                            count: 10000 * 6 * 10,
                            text: '10m'
                        }, {
                            type: 'millisecond',
                            count: 10000 * 6 * 60,
                            text: '1h'
                        }],
                    },
                }
            );
            this.setChartExtremes()
            const compressionManager = this;

            this.compressionChart = Highcharts.chart(`compression-container`, {
                chart: {
                    type: 'column',
                },
                plotOptions: {
                    series: {
                        cursor: 'pointer',
                        point: {
                            events: {
                                click: function () {
                                    compressionManager.setLevel(this.category) // "this" from outer scope
                                }
                            }
                        }
                    }
                },
                title: {
                    text: ''
                },
                yAxis: {
                    title: {
                        text: 'Storage Size in KB'
                    }
                },
                xAxis: {
                    categories: ["clickhouse", "druid", "influx", "timescaledb"],
                    labels: {
                        allowOverlap: true,
                        padding: 0,
                        enabled: false
                    },
                },

                series: Object.keys(this.initialCompression).map(system => {
                    return {
                        name: system,
                        data: [this.initialCompression[system]]
                    }
                })
            });
        }

        createDropdown() {
            const dropdown = document.createElement('select');
            dropdown.id = `inside-dropdown`;
            dropdown.className = 'form-control';
            dropdown.addEventListener('change', (event) => {
                this.setLevel(event.target.value)
                document.getElementById("showCompression").style.display = "none";
            });


            for (const level of this.levels) {
                const levelOption = document.createElement('option');
                levelOption.value = level;
                levelOption.text = level;
                dropdown.add(levelOption);
            }
            const levelDropdown = document.getElementById('level-dropdown');
            levelDropdown.innerHTML = '';

            levelDropdown.appendChild(dropdown);

        }

        setLevel(level) {
            console.log("set level")
            this.currentLevel = level;
        }

        displayCompression() {
            var level = this.currentLevel
            this.compressionChart.series.forEach((series) => {
                series.setData([this.data[level]["compression"][series.name]]);
            });
        }

        displayChart() {
            var level = this.currentLevel
            while (this.dataChart.series.length > 3) {
                this.dataChart.series[3].remove(false);
            }

            // Update the charts based on the current level
            const newData = this.data[level]["data"];
            let counter = 0


            if (this.dataType === "scarsity") {
                var used_colors = []
                this.dataChart.series.forEach(
                    //update series opacity and line style
                    (series) => {
                        series.update({
                            opacity: 0.5,
                            dashStyle: 'dot',
                        }, true);
                        used_colors.push(series.color)
                    }
                )
                for (const sensor of Object.keys(newData)) {
                    if (sensor === 'time') continue;
                    try {
                        const newChartData = newData[sensor].map((value, index) => [this.chartTime[index], value]);
                        {#this.dataChart.get(sensor).setData(newChartData);#}
                        //  delete series with index larger than 3

                        this.dataChart.addSeries({
                            name: sensor + "_" + level,
                            id: sensor + level,
                            data: newChartData,
                            linkedTo: sensor,
                            visible: counter === 0,
                            showInLegend: false,
                            color: used_colors[counter]
                        });
                    } catch (e) {
                        console.log(sensor);
                        console.log(e);
                    }
                    counter = counter + 1 // 3 sensors
                }

            } else if (this.dataType === "outliers") {
                for (const sensor of Object.keys(newData)) {
                    if (sensor === 'time') continue;
                    try {
                        const newChartData = newData[sensor].map((value, index) => [this.chartTime[index], value]);

                        this.dataChart.addSeries({
                            name: sensor + "_" + level,
                            id: sensor + level,
                            data: newChartData,
                            linkedTo: sensor,
                            zIndex: -1,
                            color: 'rgba(255, 0, 0, 1)',
                            visible: counter === 0,
                            showInLegend: false,
                        });
                    } catch (e) {
                        console.log(sensor);
                        console.log(e);
                    }
                    counter = counter + 1 // 3 sensors
                }

            } else {
                var used_colors = []
                this.dataChart.series.forEach(
                    //update series opacity and line style
                    (series) => {
                        series.update({
                            opacity: 0.5,
                            dashStyle: 'dot',
                        }, true);
                        used_colors.push(series.color)
                    }
                )
                for (const sensor of Object.keys(newData)) {
                    if (sensor === 'time') continue;
                    try {
                        const newChartData = newData[sensor].map((value, index) => [this.chartTime[index], value]);
                        {#this.dataChart.get(sensor).setData(newChartData);#}
                        //  delete series with index larger than 3

                        this.dataChart.addSeries({
                            name: sensor + "_" + level,
                            id: sensor + level,
                            data: newChartData,
                            linkedTo: sensor,
                            visible: counter === 0,
                            showInLegend: false,
                            color: used_colors[counter]
                        });
                    } catch (e) {
                        console.log(sensor);
                        console.log(e);
                    }
                    counter = counter + 1 // 3 sensors
                }

            }
        }
    }

</script>